<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="温故而知新"><title>Go错误处理 | 怪叔叔的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go错误处理</h1><a id="logo" href="/.">怪叔叔的博客</a><p class="description">攀峰之高险，岂有崖巅。搏海之明辉，何来彼岸。前进不止，奋斗不息。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Go错误处理</h1><div class="post-meta">Jan 24, 2019</div><div class="post-content"><h3 id="Go错误处理"><a href="#Go错误处理" class="headerlink" title="Go错误处理"></a>Go错误处理</h3><p>错误处理是学习任何编程语言都需要考虑的重要话题。</p>
<h5 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h5><p>Go语言引入了一个关于错误处理标准模式，即error接口。这个接口是interface类型<br>该接口的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他们通常在编码中通过实现error接口类型来生产错误信息。\<br>函数通常在最后的返回值中反回错误信息。\<br>创建一个error最简单的方法就是调用errors.New函数，它回根据传入的错误信息返回一个新的error。\<br>整个errros包仅仅只有4行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package errors</span><br><span class="line"></span><br><span class="line">func New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125;</span><br><span class="line"></span><br><span class="line">type errorString struct &#123; text string &#125;</span><br><span class="line"></span><br><span class="line">func (e *errorString) Error() string &#123; return e.text &#125;</span><br></pre></td></tr></table></figure></p>
<p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//定义一个 DivideError 结构</span><br><span class="line">type DivideError struct &#123;</span><br><span class="line">	dividee int</span><br><span class="line">	divider int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现error 接口</span><br><span class="line">func (de *DivideError) Error() string &#123;</span><br><span class="line">	strFormat := `</span><br><span class="line"> 		Cannot proceed, the divider is zero</span><br><span class="line">		dividee: %d</span><br><span class="line">		divider: 0</span><br><span class="line">		`</span><br><span class="line">	return fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义`int` 类型除法运算的函数</span><br><span class="line">func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;</span><br><span class="line">	if varDivider == 0 &#123;</span><br><span class="line">		dData := DivideError&#123;</span><br><span class="line">			dividee: varDividee,</span><br><span class="line">			divider: varDivider,</span><br><span class="line">		&#125;</span><br><span class="line">		errorMsg = dData.Error()</span><br><span class="line">		return</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return varDividee / varDivider, &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	//正常情况下</span><br><span class="line">	if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;</span><br><span class="line">		fmt.Println(&quot;100/10 = &quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">	//当被除数为零的时候会返回错误信息</span><br><span class="line">	if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;</span><br><span class="line">		fmt.Println(&quot;errorMsg is: &quot;, errorMsg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a></p>
<h5 id="defer-关键字"><a href="#defer-关键字" class="headerlink" title="defer 关键字"></a>defer 关键字</h5><p> defer是Go语言提供的关键字，defer一般用于异常处理、资源释放、清理数据、记录日志等。<br>有点像面向对象语言的<a href="https://baike.baidu.com/item/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">析构函数</a>,会在函数返回之前进行调用。如果有多个defer表达式，<br>调用顺序类似与干栈，越后面的defer表达式越先被调用。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer fmt.Println(i) //此时i=0</span><br><span class="line">	i++</span><br><span class="line">	defer fmt.Println(i) //此时i=1</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  输出结果：</span><br><span class="line">  1</span><br><span class="line">  0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>这个时defer的一个特性。</p>
<p>那么defer都有哪些特性:</p>
<ul>
<li><p>defer表达式中变量的值在defer表达式被定义时就已经明确,参数会实时解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer fmt.Println(i) //此时i=0</span><br><span class="line">	i++</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  输出结果：o</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>我们都知道，defer函数会在return之后被调用。那么这段函数执行之后，是不是应该输出1，但是为什么是0呢？<br>上面的代码用到了i这个变量，i再初始化之后的值为0，接着程序执行到defer表达式这一行，但是这个变量i，<br>在defer被声明的时候，就已经确认其确定的值0了，接着表达式被放入到list中。等待return的时候被调用。<br>所以，后面尽管有一个i++语句，仍然不能改变表达式fmt.Println(i)的结果。</p>
</li>
<li><p>defer表达式的调用式安装先进后出的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	defer fmt.Println(1)</span><br><span class="line">	defer fmt.Println(2)</span><br><span class="line">	defer fmt.Println(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  输出结果：</span><br><span class="line">  3</span><br><span class="line">  2</span><br><span class="line">  1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>defer表达式会被放入一个类似于栈(stack)的机构，所以调用的顺序是后进先出。所以上面代码输出的结果是321，而不是123，实际编码中应该注意。程序后面的defer表达式会被优先执行。</p>
</li>
<li>defer表达式中可以修改函数中的命名返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func a(s string) (n int, err error) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		log.Printf(&quot;a(%q) = %d, %v&quot;, s, n, err)</span><br><span class="line">	&#125;()</span><br><span class="line">	return 7, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a(&quot;Go&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//输出结果：</span><br><span class="line">//2019/01/30 17:31:49 a(&quot;Go&quot;) = 7, EOF</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Golang中的函数返回值是可以命名的，这也是Golang带给开发人员的一个比较方便特性。可以用来记录函数的参数与返回值</p>
<h4 id="panic-和recover"><a href="#panic-和recover" class="headerlink" title="panic()和recover()"></a>panic()和recover()</h4><p>defer除了用于简化资源的释放外，还是go语言异常处理框架的一个组成部分。\<br>go语言中，panic用于抛出异常,recover用于捕获异常.recover只能在defer语句中使用，直接调用recover是无效的。<br>实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	panic(&quot;a problem test&quot;)</span><br><span class="line">	fmt.Println(1)</span><br><span class="line">	_, err := os.Create(&quot;/tmp/filetest&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输出结果：</span><br><span class="line">panic: a problem test</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/Users/go/src/hello/panic.go:6 +0x39</span><br><span class="line">exit status 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，panic用来表示异常，即不该出现的错误，或者意料不到的错误。当函数中包含panic的时候终止该函数。<br>这里panic产生了一个异常，然后下面就停止运行了。并且返回了一个非0状态码。<br>因为golang中没有try…catch..,所以当go遇到panic的时候，如果不进行recover，便会导致整个程序挂掉。</p>
<p>如何不让程序挂掉，继续执行下去呢。这个时候就需要用defer延迟处理recover进行回复。具体如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	defer func() &#123; //必须要先声明defer，否则不能捕获到panic异常</span><br><span class="line">		fmt.Println(&quot;2&quot;)</span><br><span class="line">		if err := recover(); err != nil &#123;</span><br><span class="line">			fmt.Println(err) //这里的err其实就是panic传入的内容，bug</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(&quot;3&quot;)</span><br><span class="line">	&#125;()</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f() &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		fmt.Println(&quot;1&quot;)</span><br><span class="line">		panic(&quot;bug&quot;)</span><br><span class="line">		fmt.Println(&quot;4&quot;) //不会运行的.</span><br><span class="line">		time.Sleep(1 * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序首先会先运行panic,出现故障,此时跳转到包含recover()的defer函数执行。recover捕获panic,此时panic就不继续传递。但是recover之后，<br>程序并不会返回到panic那个点继续执行，而是在recover这个点继续执行之后的动作。输出3.</p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/Golang/">Golang</a></div><div class="post-nav"><a class="pre" href="/2019/01/28/tengine安装/">tengine安装</a><a class="next" href="/2019/01/24/开源DNS管理系统OpenDnsdb/">开源DNS管理系统OpenDnsdb</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://dingbingbing.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/ELK/" style="font-size: 15px;">ELK</a> <a href="/tags/Switch/" style="font-size: 15px;">Switch</a> <a href="/tags/Open-Falcon/" style="font-size: 15px;">Open-Falcon</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/salt/" style="font-size: 15px;">salt</a> <a href="/tags/tengine/" style="font-size: 15px;">tengine</a> <a href="/tags/IaaS/" style="font-size: 15px;">IaaS</a> <a href="/tags/Gin/" style="font-size: 15px;">Gin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/02/27/交换机日志监控/">交换机日志监控</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/26/有关Gin框架基础介绍/">有关Gin框架基础介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/26/如何在iTerm2上加按钮，点一下执行设置好的命令/">如何在iTerm2上加按钮，点一下执行设置好的命令?</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/21/Go目录清单/">Go安装目录清单</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/21/Go生成代码文档/">Go生成代码文档</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/20/hexo如何设置多个tags/">hexo如何设置多个tags</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/19/Go语言标准库/">Go语言标准库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/hexo-dns解析报错解决/">hexo dns解析报错解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/14/centos6在线升级到centos7/">centos6在线升级到centos7</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/Go开发环境的基本要求/">Go开发环境的基本要求</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://studygolang.com/" title="golang中文社区" target="_blank">golang中文社区</a><ul></ul><a href="http://www.sec-wiki.com/" title="sec-wiki" target="_blank">sec-wiki</a><ul></ul><a href="http://www.runoob.com/" title="菜鸟笔记" target="_blank">菜鸟笔记</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">怪叔叔的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>